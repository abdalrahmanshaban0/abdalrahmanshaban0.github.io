---
layout: post
title: Queue
date: 2025-01-18 13:17 +0200
category: [DSA]
tags: [Data Structures And Algorithms, Queue]
---
Queue is a simple data structure serves collection of elements with 2 main operations (enqueue and dequeue). The order of each element is added or removed from a stack is referred by **FIFO** (First In First Out).
## Array-Based Implementation
![Array-Based Queue](/assets/posts/DSA/array_queue.png)
```cpp
template <typename E>
class ArrayQueue
{
  enum
  {
    DEF_CAPACITY = 100
  };

public:
  ArrayQueue(int cap = DEF_CAPACITY)
  {
    n = f = r = 0;
    capacity = cap;
    arr = new E[cap];
  }
  int size() const
  {
    return n;
  }
  bool empty() const
  {
    return n == 0;
  }
  const E &front() const
  {
    if (empty())
    {
      throw runtime_error("Front of empty queue");
    }
    return arr[f];
  }
  void enqueue(const E &e)
  { // push back
    if (r == capacity)
    {
      throw runtime_error("Push to full queue");
    }
    arr[r++] = e;
    n++;
    r %= capacity;
  }
  void dequeue()
  { // pop front
    if (empty())
    {
      throw runtime_error("Pop from empty queue");
    }
    f++;
    f %= capacity;
    n--;
  }

private:
  E *arr;
  int capacity;
  int n; // current no. of elements
  int f; // index of the front
  int r; // index of the rear
};
```

## Implementing Queue with Circularly Linked List 
We'll use [Circularly linked list](https://abdalrahmanshaban0.github.io/posts/linked-list/) implemented before.
this is how we can do the enqueue and dequeue with it:
### enqueue
![Queue push with circularly linked list](/assets/posts/DSA/CQueue_push.png)
### dequeue
![Queue pop with circularly linked list](/assets/posts/DSA/CQueue_pop.png)
### LinkedQueue
```cpp
template <typename E>
class LinkedQueue
{
public:
  LinkedQueue()
  {
    n = 0;
    C();
  }
  int size() const
  {
    return n;
  }
  bool empty() const
  {
    return n == 0;
  }
  const E &front() const
  {
    if (empty())
      throw(runtime_error("Front of empty queue"));
    return C.front();
  }
  void enqueue(const E &e)
  {
    C.add(e);
    C.advance();
    n++;
  }
  void dequeue()
  {
    if (empty())
      throw(runtime_error("Dequeue from empty queue"));
    C.remove();
    n--;
  }

private:
  CircleList<E> C;
  int n;
};
```

## Double-Ended Queue (Deque)
Generalizes a Queue as elements can be added or removed from either the front (head) or back(tail). This ADT can very easily be implemented using a [doubly linked list](https://abdalrahmanshaban0.github.io/posts/linked-list/).
```cpp
template <typename E>
class LinkedDeque
{
public:
  LinkedDeque()
  {
    n = 0;
  }
  int size() const
  {
    return n;
  }
  bool empty() const
  {
    return n == 0;
  }
  const E &front() const
  {
    if (empty())
      throw(runtime_error("Front of empty deque"));
    return D.front();
  }
  const E &back() const
  {
    if (empty())
      throw(runtime_error("Back of empty deque"));
    return D.back();
  }
  void insertFront(const E &e)
  {
    D.addFront(e);
    n++;
  }
  void insertBack(const E &e)
  {
    D.addBack(e);
    n++;
  }
  void removeFront()
  {
    if (empty())
      throw(runtime_error("Remove front of empty deque"));
    D.removeFront();
    n--;
  }
  void removeBack()
  {
    if (empty())
      throw(runtime_error("Remove back of empty deque"));
    D.removeBack();
    n--;
  }

private:
  DLinkedList<E> D;
  int n;
};
```

Images from [DSA in C++](https://www.amazon.com/Data-Structures-Algorithms-Michael-Goodrich/dp/0470383275) book.